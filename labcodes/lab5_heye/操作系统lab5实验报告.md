#### 练习1: 加载应用程序并执行（需要编码）

**do_execve**函数调用`load_icode`（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充`load_icode`的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好`proc_struct`结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。

请在实验报告中简要说明你的设计实现过程。

- 请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

#### 设计实现过程简述

1. **创建 mm_struct**：为当前进程分配新的内存管理结构体（mm），并分配页目录表（PDT）。
2. **解析ELF文件**：遍历ELF的每个可加载段（PT_LOAD），为其分配虚拟内存区域（VMA），并将二进制内容拷贝到物理内存，BSS段清零。
3. **建立用户栈**：为用户栈分配虚拟内存，并分配实际物理页。
4. **切换页表**：将当前进程的mm和页表物理地址写入proc_struct和satp寄存器。
5. **设置trapframe**：清空trapframe，设置sp为用户栈顶，epc为ELF入口，status为用户模式并允许中断。

#### trapframe设置的作用

- `tf->gpr.sp = USTACKTOP;`：设置用户栈顶，保证用户程序运行时有栈空间。
- `tf->epc = elf->e_entry;`：设置用户程序的入口地址，CPU从这里开始执行用户代码。
- `tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;`：切换到用户模式，并允许中断。

------

### 用户态进程从RUNNING到执行应用程序第一条指令的过程

1. **进程被调度为RUNNING**：调度器选择该进程，调用`proc_run`，切换到该进程的内核栈和页表。
2. **上下文切换**：`switch_to`保存当前进程上下文，恢复新进程上下文。
3. **trapframe准备**：`trapframe`已在`load_icode`中设置好，包含用户栈顶、入口地址、用户模式等信息。
4. **从内核返回用户态**：通过`eret`等指令（或类似机制），CPU根据trapframe内容切换到用户模式，PC跳转到`tf->epc`，SP为`tf->gpr.sp`。
5. **执行用户程序**：CPU开始执行用户程序的第一条指令，正式进入用户空间。

------

### 总结

- `load_icode`负责建立用户进程的内存空间和trapframe，确保用户程序能从入口地址、用户栈顶、用户模式开始执行。
- 进程被调度后，内核通过trapframe内容安全地切换到用户空间，执行用户程序。





#### 练习2: 父进程复制自己的内存空间给子进程（需要编码）

创建子进程的函数`do_fork`在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过`copy_range`函数（位于kern/mm/pmm.c中）实现的，请补充`copy_range`的实现，确保能够正确执行。

请在实验报告中简要说明你的设计实现过程。

- 如何设计实现`Copy on Write`机制？给出概要设计，鼓励给出详细设计。

> Copy-on-write（简称COW）的基本概念是指如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源了。若某使用者需要对这个资源A进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝—资源B，可对资源B进行写操作。该“写操作”使用者对资源B的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源A。



copy_range 已补全，核心实现为：

1. 遍历父进程页表，找到每个有效页。
2. 为子进程分配新物理页，将父进程物理页内容 memcpy 到新页。
3. 用 page_insert 建立新页与子进程虚拟地址的映射，权限与父进程一致。

------

### 实验报告简要说明

- 设计思路：遍历父进程用户空间的每一页，对每一页分配新物理页，拷贝内容，并建立映射，确保子进程拥有独立的用户空间副本。
- 关键点：使用 page2kva 获取物理页虚拟地址，memcpy 拷贝内容，page_insert 建立映射。

------

### Copy on Write（COW）机制概要设计

1. **页表共享**：fork 时，父子进程页表指向同一物理页，均设为只读，并增加引用计数。
2. **写时异常**：当任一进程写该页时，触发页异常（Page Fault）。
3. **异常处理**：操作系统分配新物理页，将原页内容复制到新页，更新当前进程页表为可写，引用计数减一。
4. **优势**：只有在写操作发生时才复制，节省内存和提升效率。

**详细设计可进一步展开，如需代码示例或更详细流程请告知。**









